/* Brain I/O: .m file as executable brain

The .m file IS the brain - it contains the learned patterns, edges, and execution state.
melvin.c interprets and executes it.

*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>

/* Forward declare MelvinGraph */
typedef struct MelvinGraph MelvinGraph;

/* Save brain to .m file */
int melvin_save_brain(MelvinGraph *g, const char *filename) {
    FILE *f = fopen(filename, "w");
    if (!f) return -1;
    
    fprintf(f, "# Melvin o7 Brain File\n");
    fprintf(f, "# This file IS the brain - patterns, edges, and learned state\n");
    fprintf(f, "# Generated by melvin.c interpreter\n\n");
    
    /* Save patterns */
    fprintf(f, "# Patterns (learned sequences with predictions)\n");
    for (uint32_t p = 0; p < g->pattern_count; p++) {
        Pattern *pat = &g->patterns[p];
        if (pat->strength < 0.01f) continue;  /* Skip weak patterns */
        
        fprintf(f, "pattern \"");
        for (uint32_t i = 0; i < pat->length; i++) {
            if (pat->node_ids[i] == 256) {
                fprintf(f, "_");  /* Blank node */
            } else {
                fprintf(f, "%c", (uint8_t)pat->node_ids[i]);
            }
        }
        fprintf(f, "\"");
        
        /* Predictions */
        if (pat->prediction_count > 0) {
            fprintf(f, " -> \"");
            for (uint32_t pred = 0; pred < pat->prediction_count && pred < 3; pred++) {
                if (pat->prediction_weights[pred] > 0.3f) {
                    fprintf(f, "%c", (uint8_t)pat->predicted_nodes[pred]);
                }
            }
            fprintf(f, "\"");
        }
        
        /* Context */
        fprintf(f, " context:[");
        for (int i = 0; i < 16; i++) {
            fprintf(f, "%.2f", pat->context_vector[i]);
            if (i < 15) fprintf(f, ",");
        }
        fprintf(f, "]");
        
        fprintf(f, " strength:%.4f utility:%.4f\n", 
                pat->strength, 
                (pat->prediction_attempts > 0) ? 
                    (float)pat->prediction_successes / (float)pat->prediction_attempts : 0.5f);
    }
    
    fprintf(f, "\n# Edges (learned connections)\n");
    /* Save significant edges */
    for (uint32_t i = 0; i < BYTE_VALUES; i++) {
        EdgeList *out = &g->outgoing[i];
        for (uint32_t e = 0; e < out->count; e++) {
            if (out->edges[e].active && out->edges[e].weight > 0.1f) {
                fprintf(f, "edge '%c' -> '%c' weight:%.4f\n",
                        (uint8_t)i,
                        (uint8_t)out->edges[e].to_id,
                        out->edges[e].weight);
            }
        }
    }
    
    fprintf(f, "\n# System state\n");
    fprintf(f, "state error_rate:%.4f learning_rate:%.4f\n",
            g->state.error_rate, g->state.learning_rate);
    
    fclose(f);
    return 0;
}

/* Load brain from .m file */
MelvinGraph* melvin_load_brain(const char *filename) {
    /* This would parse the .m file and build the graph */
    /* For now, return NULL - full parser needed */
    return NULL;
}

